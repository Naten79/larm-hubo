#!/usr/bin/python3
import rclpy
import numpy as np
import matplotlib.pyplot as plt
from rclpy.node import Node
from std_msgs.msg import String
from sensor_msgs.msg import Image
#from kobuki_ros_interfaces.msg import Sound
from visualization_msgs.msg import Marker
from visualization_msgs.msg import MarkerArray
from cv_bridge import CvBridge
from geometry_msgs.msg import Point
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Quaternion
from std_msgs.msg import String
import cv2
import time


def listen():
    # Initialize ROS node with ROS client
    rclpy.init()
    aNode= Node( "listener" )
    listener= ROSListener()
    listener.initializelistener(aNode)
    rclpy.spin(aNode)

    # Clean everything and switch the light off
    aNode.destroy_node()
    rclpy.shutdown()



class ROSListener():

    def __init__(self):
        self.L=[]
        self.bool = 0
        self.b = 1
        self.coord = []
        self.compteur = 0
        self.mot=String()
        self.incr=0.0
        self.marker=MarkerArray()
        self.marker1=Marker()
        self.marker1.header.frame_id='base_link'
        self.marker1.id=0
        self.marker1.ns="/marker"
        self.marker1.action=Marker.ADD
        self.marker1.type=Marker.CUBE
        self.marker1.scale.x = 0.5
        self.marker1.scale.y = 0.5
        self.marker1.scale.z = 0.5
        self.marker1.color.a=1.0
        self.marker1.color.r=0.0
        self.marker1.color.g=0.0
        self.marker1.color.b=0.0
        self.marker1.pose = Pose()
        self.marker1.pose.position = Point(x=0.0, y=0.0, z=0.0)
        self.marker1.pose.orientation = Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)
        
        self.marker.markers.append(self.marker1)


    def initializelistener(self, rosNode):
        self._logger= rosNode.get_logger()
        self._publisher1=rosNode.create_publisher(MarkerArray,'visualization_msgs/marker',10)

        self._sub=rosNode.create_subscription(String,'Apres_tf',self.listener_callback,10)
        # Publish a message every 1 second
        #timer_period = 1 # seconds
        #self._timer = rosNode.create_timer(timer_period, self.publish_marker)


    def listener_callback(self,msg):
        self.mot=msg
        if self.mot.data!='':
            x, y = (float(self.mot.data.split(',',2)[0]), float(self.mot.data.split(',',2)[1]))
            # self.coord.append(float(self.mot.data.split(',',2)[0]))         #ajout de la coordonnée x dans la liste coord
            # self.coord.append(float(self.mot.data.split(',',2)[1]))         #ajout de la coordonnée y dans la liste coord
            add_point = True
            for point in self.L:
                if ((point[0]-x)**2+(point[1]-y)**2)<1.0 :
                    add_point = False

            if add_point:
                self.L.append((x, y))
                self.publish_marker((x,y))

            # self.coord=[]
            # for point in self.L:
            #     for p in self.L:
            #         print((point[0]-p[0])**2+(point[1]-p[1])**2)
            #         if ((point[0]-p[0])**2+(point[1]-p[1])**2)<0.1 :      #si le point est situé proche d'un marqueur existant, le marqueur n'apparait pas ce qui permet de savoir si le fantôme a déjà été détecté
            #             self.bool = self.bool+1
            #     if self.bool<2:
            #         self.publish_marker(point)
            #     else :
            #         self.L.pop()                                    # le dernier point détecté est trop proche de marqueur existant, il correspond donc à un fantôme déjà cartographié
            #     self.bool = 0

    def publish_marker(self,point):
        #for point in self.L:                                     
        m = Marker()
        m.action=Marker.ADD
        m.type=Marker.CUBE
        m.header.frame_id='map'
        m.id=self.b                                         #correspond au numéro du fantôme détecté sur le carte
        m.ns="marker"+str(m.id)
        m.scale.x = 0.2
        m.scale.y = 0.2
        m.scale.z = 0.2
        m.color.a=1.0
        m.color.r=0.0
        m.color.g=1.0
        m.color.b=0.0
        m.pose = Pose()
        m.pose.position = Point(x=point[0], y=point[1], z=0.0)
        m.pose.orientation = Quaternion(x=0.0, y=0.0, z=0.0, w=1.0)
        self.marker.markers.append(m)
        self.b+=1
                    
                    #self.marker.header.stamp = rclpy.time.Time().to_msg()  # Set the timestamp
        self._publisher1.publish(self.marker)
                    #self._logger.info('Publishing marker: {}'.format(self.marker))
                    #self.marker.pose.position = Point(x=1.0, y=1.0, z=1.0)

if __name__ == '__main__':
    listen()
